---
title: 日期格式正则表达式
category:
  - 正则表达式
---

# 日期格式正则表达式验证指南

## 目录

[[toc]]

## 基本概念

### 合法日期范围
在不同的应用场景中，合法日期范围可能有所不同。一般遵循以下规范：
- 最小日期：0001年1月1日 00:00:00
- 最大日期：9999年12月31日 23:59:59
### 闰年规则
闰年的判定基于以下原理：
1. 地球绕太阳一周（回归年）约为365.2422日
2. 为保持历法准确，采用以下规则：
   - 普通年份能被4整除的为闰年
   - 世纪年份（能被100整除的年份）必须能被400整除才是闰年
   - 例如：1996年是闰年，1900年不是闰年，2000年是闰年
## 日期验证方案

### 1. 年份验证
- 有效范围：0001 - 9999
- 基本正则表达式：
```javascript
[0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}
```

### 2. 日期验证的主要难点

1. 不同月份的天数差异

2. 闰年的特殊处理

对于第一个难点，我们首先不考虑闰年，假设2月份都是28天，这样，月份和日期可以分成三种情况：

**1、月份为 1, 3, 5, 7, 8, 10, 12，天数范围为 01 - 31，匹配MM-DD的正则表达式为：**

```
(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])
```

**2、月份为 4, 6, 9, 11，天数范围为 01-30，匹配MM-DD的正则表达式为：**

```
(0[469]|11)-(0[1-9]|[12][0-9]|30)
```

**3、月份为 2，考虑平年情况，匹配MM-DD的正则表达式为：**

```
02-(0[1-9]|[1][0-9]|2[0-8])
```

**根据上面的成果，我们可以得到匹配平年日期格式为YYYY-MM-DD的正则表达式：**

```
([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8])))
```

接着我们来解决第二个难点：闰年的考虑。根据闰年的定义，我们可以将闰年分为两类：

**1、能被4整除但不能被100整除的年份。寻找后两位的变化规律，可以很快得到下面的正则匹配：**

```
([0-9]{2})(0[48]|[2468][048]|[13579][26])
```
**2、能被400整除的年份。能被400整除的数肯定能被100整除，因此后两位肯定是00，我们只要保证前两位能被4整除即可，相应的正则表达式为：**

```
(0[48]|[2468][048]|[3579][26])00
```

**闰年的2月份有29天，因此匹配闰年日期格式为YYYY-MM-DD的正则表达式为：**

```
(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29
```

**最后，将平年和闰年的日期验证表达式合并，我们得到最终的验证日期格式为YYYY-MM-DD的正则表达式为：**

```
(([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29)
```

**DD/MM/YYYY格式的正则验证表达式为：**

```
(((0[1-9]|[12][0-9]|3[01])/((0[13578]|1[02]))|((0[1-9]|[12][0-9]|30)/(0[469]|11))|(0[1-9]|[1][0-9]|2[0-8])/(02))/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}))|(29/02/(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00)))
```

### 3. 常用日期验证正则表达式

#### 3.1 基础格式验证

支持YYYY/MM/DD格式：

```
^\\d{4}(\\-|\\/|\\.)\\d{1,2}\\1\\d{1,2}$
```

#### 3.2 增强格式验证

支持多种格式（YYYY/MM/DD 或 YY/MM/DD）：

```
^(^(\\d{4}|\\d{2})(\\-|\\/|\\.)\\d{1,2}\\3\\d{1,2}$)|(^\\d{4}年\\d{1,2}月\\d{1,2}日$)$
```
三、加入闰年的判断的：
　　^((((1\[6-9\]|\[2-9\]\\d)\\d{2})-(0?\[13578\]|1\[02\])-(0?\[1-9\]|\[12\]\\d|3\[01\]))|(((1\[6-9\]|\[2-9\]\\d)\\d{2})-(0?\[13456789\]|1\[012\])-(0?\[1-9\]|\[12\]\\d|30))|(((1\[6-9\]|\[2-9\]\\d)\\d{2})-0?2-(0?\[1-9\]|1\\d|2\[0-8\]))|(((1\[6-9\]|\[2-9\]\\d)(0\[48\]|\[2468\]\[048\]|\[13579\]\[26\])|((16|\[2468\]\[048\]|\[3579\]\[26\])00))-0?2-29-))$
...
诸如此类。
实际上仅仅对字符串做验证，并不严密，而且费力。
下面介绍一种结合正则和日期函数的验证方式：

```js
/**
         * 验证日期格式
         * @param date
         * @return {boolean}
         */
        function checkDate(date) {
            var result = date.match(/^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/);

            if (result == null)
                return false;
            var d = new Date(result[1], result[3] - 1, result[4]);
            return (d.getFullYear() == result[1] && (d.getMonth() + 1) == result[3] && d.getDate() == result[4]);
        }
```
