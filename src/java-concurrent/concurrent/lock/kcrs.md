---
title: 可重入锁的实现原理
category:
  - Java并发编程
tag:
  - Lock
  - java.util.concurrent
---

## 可重入锁的实现原理

可重入锁的核心实现机制基于**线程持有者记录**和**重入计数器**：

## 目录

[[toc]]

### 核心组件
- **线程持有者（Owner Thread）**：记录当前持有锁的线程
- **重入计数器（Reentrant Count）**：记录同一线程获取锁的次数

### 工作流程

**1. 初始状态**
- 计数器 = 0
- 持有者 = null
- 锁处于未被持有状态

**2. 首次获取锁**
- 线程A请求锁时，发现计数器为0
- 设置持有者为线程A，计数器置为1
- 线程A成功获取锁

**3. 重入获取**
- 线程A再次请求同一把锁
- 检查发现当前持有者就是线程A本身
- 计数器递增：1 → 2 → 3...
- 无需等待，直接获取成功

**4. 其他线程请求**
- 线程B请求该锁时，发现持有者不是自己
- 线程B进入等待状态，直到锁被释放

**5. 锁释放过程**
- 线程A每次退出同步代码块，计数器递减
- 3 → 2 → 1 → 0
- 当计数器归零时，清空持有者，完全释放锁
- 唤醒等待队列中的其他线程

### 关键特性
- **线程独占性**：只有持有锁的线程才能重入
- **配对释放**：获取几次锁就必须释放几次
- **计数准确性**：确保嵌套调用的正确性

这种设计既保证了线程安全，又避免了同一线程的死锁问题，是现代锁机制的基础实现原理。